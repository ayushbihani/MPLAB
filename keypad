assume cs:code,ds:data

data segment
pa equ 20A0h
pb equ 20A1h
pc equ 20A2h
cr equ 20A3
rowval db ?
colval db ?
scode db ?
rowmsg db "Row is = $"
colmsg db "column is = $ "
key db "key is = $"

display macro
    mov ah,09
    int 21h
endm
data ends

code segment

start :mov ax,data
        mov ds,ax
        mov dx,cr
        mov al,90h
        out dx,al
        
  rpt:  
      mov bl,04
      mov bh,03
      mov cl,10h
      
  row:
      mov dx,pc
      mov al,bl
      out dx,al
      
      mov dx,pa
      in al,dx
      cmp al,00h ;to check if no key was pressed
      jne ahead ;if pressed then go ahead
      shr bl,1 
      sub cl,08
      
      dec bh
      jnz row
      jmp rpt ;infinite loop 
      
    ahead : 
          mov row,bh ;row value in bh
          mov ah,1 ;now to calculate which column 
          
    check:
          rcr al,1 ;when any key is pressed the column no is in form of binary and is stored in al ,itll be 1 so u search for that 1
          jc next
          inc ah   ; column number
          inc cl ;what key youve pressed value be in cl 
          jmp check
          
    next :
          mov col,ah
          mov scode,cl
          mov ah,00
          lea dx,rowmsg ;printing row value
          display ;macro 
          mov ax,row
          call disp
          lea dx,colmsg
          display 
          mov ax,col
          call disp
          lea dx,key
          display
          mov ax,scode
          call disp
          
          mov ah,4ch 
          int 21h
          
          code ends
          end start
          
          
          
          
          
          
          
  disp proc ;works upto 16 bit hexcadecimal ,decimals numbers .prints the number in decimal .number should be in AX
            
            mov dx,0
            mov cx,10
            mov count ,0
            rep: div cx  ;takes reminder (normal division )to get each digit 
                  push dx ;push them on stack.dx will have the reminder
                 mov dx,0
                 inc count ;to keep a track of the no of digits
                 cmp ax,0 ;when reminder is 0 that means all deigits are pushed onto the stack
                 jne rep
                 
      disp1: pop dx  ; if number is 456 top of the stack will be 4 then 5 and then 6 .so print each of them adding 30h 
                  add dl,30h
                  mov ah,2
                  int 21h
                  
                  dec count
                  jnz disp1
                  
                  ret
                  disp endp
